from sympy import *


class FSpace(object):
    r"""
    This class defines a function space by taking a family of sympy 
    symbolic functions and relations among them.
    Simply, it initiates a commutative free real algebra on the symbolic
    functions and defines the function space as the quotient of the free
    algebra by the ideal generated by the given relations.
    """
    GensError = r"""The `gens` must be a list of sympy function symbols."""
    RelsError = r"""The `relations` must be a list of relation among generators"""

    def __init__(self, gens, relations=[]):
        assert type(gens) is list, self.GensError
        assert type(gens) is list, self.RelsError
        from sympy import Function, Symbol, QQ, RR, groebner
        self.Field = QQ
        self.Generators = []
        self.SymDict = {}
        self.AuxSyms = []
        self.NumGenerators = 0
        self.FreeRelations = []
        self.Groebner = []
        # check generators
        for f in gens:
            if isinstance(f, Function):
                self.Generators.append(f)
                self.NumGenerators += 1
                t_sym = Symbol('X%d' % self.NumGenerators)
                self.SymDict[f] = t_sym
                self.AuxSyms.append(t_sym)
            else:
                raise TypeError(self.GensError)
        # check the relations
        # TBI
        for r in relations:
            t_rel = r.subs(self.SymDict)
            self.FreeRelations.append(t_rel)
        if self.FreeRelations != []:
            self.Groebner = groebner(
                self.FreeRelations, domain=self.Field, order='grevlex')
        self.FreeAlg = self.Field.old_poly_ring(*self.AuxSyms)

    def ReduceExp(self, exp):
        r"""
        Takes an expression, either in terms of internal free symbolic 
        variables or generating functions and returns the reduced expression
        in terms of internal symbolic variables, if a relation among generators
        is present, otherwise it just substitutes generating functions with 
        their corresponding internal symbols.
        """
        from sympy import reduced
        T = exp.subs(self.SymDict)
        if self.Groebner != []:
            return reduced(T, self.Groebner)[1]
        else:
            return T

    def ReducedMonoBase(self, deg):
        r"""
        Returns a reduce monomial basis up to degree `d`.
        """
        from itertools import product
        from operator import mul
        from sympy import Poly
        all_monos = product(range(deg + 1), repeat=self.NumGenerators)
        req_monos = filter(lambda x: sum(x) <= deg, all_monos)
        monos = [reduce(mul, [self.AuxSyms[i]**expn[i]
                              for i in range(self.NumGenerators)], 1) for expn in req_monos]
        RBase = []
        for expr in monos:
            rexpr = self.ReduceExp(expr)
            expr_monos = Poly(rexpr, *self.AuxSyms).as_dict()
            for mono_exp in expr_monos:
                t_mono = reduce(mul, [self.AuxSyms[i]**mono_exp[i]
                                      for i in range(self.NumGenerators)], 1)
                if t_mono not in RBase:
                    RBase.append(t_mono)
        return RBase

#######################################################################
x = Symbol('x')
f = Function('f')(x)
g = Function('g')(x)
h = Function('h')(x)

rels = [f**2 + g**2 - 1]  # , f**3 - h**2 - 1]
F = FSpace([f, g, ], rels)

s = f * g**4 - 3 * h * g - f**5 * h
print F.ReducedMonoBase(3)
